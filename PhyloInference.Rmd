---
title: "Phylogenetic Inference with SNVs and CNVs"
author: "Alan Selewa"
date: 2017-11-17
output: html_document
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(fig.width=10, fig.height=6, fig.path='Figs/',
                      echo=TRUE, warning=FALSE, message=FALSE, comment = NA)
```

```{r "setup", echo=FALSE}
knitr::opts_knit$set(root.dir = "~/sc_call_variants/")
```

## Sample 1 (BC03)

### Clustering Cells

Using a window of 150 genes, the relative CNV profiles of single cells are computed and clustered. 

```{r cluster_cnvs_bc03}
source('inferCNV.R')
results03 = clusterCNVs('03')
bc03_cnv = results03[[1]]
cells03 = results03[[2]]
genes03 = results03[[3]]
```

Next, we plot first and second principle component of the expression matrix.

```{r bc03_pca, echo=F}
bc03_pca <- prcomp(t(log2(tpms[genes03,cells03]+1)),center=TRUE,scale=TRUE)
PCcords <- as.data.frame(bc03_pca$x)[c("PC1","PC2")]
healthy <- cells03[bc03_cnv$rowInd[1:22]]
unhealthy <- cells03[!(cells03 %in% healthy)]
PCcords[healthy,"color"] <- 'blue'
PCcords[unhealthy,"color"] <- 'red'
plot(PCcords[,1],PCcords[,2],pch=16,col=PCcords[,3],xlab='PC 1',ylab='PC 2')
legend(40,-60,c('Cancerous','Healthy'),col=c('red','blue'),pch = c(16,16))
```

Based on the CNV plot above, chromosome 8 and 17 are both amplified in the top cluster. Cells within this cluster also seperate in the PC analysis. Thus, these are the cancerous cells, while the other cells are healthy cells.

Using the tree generated by the CNV profiles above, we look at how well oncogenes/tumor suppressor genes agree with the ordering obtained by CNV clustering. The oncogenes ERBB2/ERBB3 are on chromosome 6, and MYC which is on chromosome 8. Both of these chromosomes are amplified for unhealthy cells. The heatmap below confirms that the expression of these oncogenes is also elevated.

```{r bc03_cnv_ggtree, echo=FALSE}
bc03_cnv_tree = as.phylo(as.hclust(bc03_cnv$rowDendrogram))
colData = data.frame(cells=c(healthy,unhealthy),place=c(rep("Healthy",length(healthy)),rep("Cancer",length(unhealthy))))
p = ggtree(bc03_cnv_tree)
p = p %<+% colData + geom_tippoint(aes(color = place)) + geom_tiplab(size=3,hjust = -0.1) + scale_color_manual(values=c("red","blue"))
subcounts = log(t(tpms[c('ERBB2','ERBB3','MYC','PIK3CA','CCND1','BRCA1','BRCA2','ATM','TP53'),cells03])+1)
gheatmap(p,data = subcounts,offset=6, width=0.4, colnames=TRUE,font.size = 1,low='green',high='red')
```

### Mutation matrix

We now turn to trees generated by SNVs for the same set of data. Given what we know about these cells, we can benchmark the results of the SNV analysis. In particular, we know that these cells are a mix of unhealthy and healthy, so at the very least, we expect the SNV tree to seperate these two populations, as the cancer cells contain mutations that the healthy ones do not.

We load the familiar data structure for single-cell mutation profiles.

```{r}
source("readcounts_parser.R")
covmat <- gen.covmat('03')
```

As a reminder: for each cell-mutation, we count the total number of reference and alternative alleles. Under the null model, the probability of observing n alternative alleles and N-n reference alleles is given by:

$$ P(A = n) = {{N}\choose{n}}  p_{error}^{n} (1 - p_{error})^{(N-n)} $$

where $p_{error} = 0.004$ is the estimated error rate. The error rate is define as the probability of observing a mutation by chance. We perform a binomial test to obtain the p-value of our observed alternative/reference counts under the null model. We choose a cut-off of 0.05. If a cell-mutation satisfies the cutoff, then a "1" is placed in the mutation matrix and 0 otherwise. Mutations with missing data are labeled as 3. 

```{r}
phylomat <- gen.mutmat(covmat)
head(phylomat[1:10,1:5])
```

Using top 27 mutations (in terms of least missing data) on 33 cells, 66% of the entries in the mutation matrix are missing values. This is equivalent to effectively halfing the number of samples (cells) when using SCITE to reconstruct the mutation matrix.

### SCITE Output

The result from SCITE is shown below, where all the branch lengths have been set equal. The heatmap next to the tree shows 5 oncogenes and 4 tumor suppressor genes and its expression for each cell. 

```{r scite_output_bc03, echo=FALSE}
tree03 <- read.newick('~/tree_inference/bc03_trees/bc03_cellTree_ml0.newick')
cellNames <- colnames(phylomat)
tree03$tip.label <- cellNames[as.integer(tree03$tip.label)]
tree03$edge.length <- rep(1, length(tree03$node.label)+length(tree03$tip.label))
p <- ggtree(tree03)
p = p %<+% colData + geom_tippoint(aes(color = place)) + geom_tiplab(size=3,hjust = -0.1) + scale_color_manual(values=c("red","blue"))
subcounts <- as.data.frame(log(t(tpms[c('ERBB2','ERBB3','MYC','PIK3CA','CCND1','BRCA1','BRCA2','ATM','TP53'),cells03])+1))
gheatmap(p,data = subcounts,offset=3, width=0.6, colnames=TRUE,font.size = 1,low='green',high='red')
```


## Sample 2 (BC08)

The sample above is not so interesting because there seems to be only one clone and a healthy subset. It would be interesting to run this analysis on data where multiple clones exist.

### Clustering Cells

Based on the CNV profiles below, patient BC03 may have multiple clones. 

```{r bc08_cnv}
source('inferCNV.R')
result02 = clusterCNVs('08')
bc02_cnv = result02[[1]]
cells02 = result02[[2]]
genes02 = result02[[3]]
```

```{r bc08_pca, echo = F}
bc02_pca <- prcomp(t(log2(tpms[genes02,cells02]+1)),center=TRUE,scale=TRUE)
PCcords <- as.data.frame(bc02_pca$x)[c("PC1","PC2")]
healthy <- cells02[bc02_cnv$rowInd[1:6]]
unhealthy <- cells02[!(cells02 %in% healthy)]
PCcords[healthy,"color"] <- 'blue'
PCcords[unhealthy,"color"] <- 'red'
plot(PCcords[,1],PCcords[,2],pch=16,col=PCcords[,3],xlab='PC 1',ylab='PC 2')
legend(20,45,c('Cancer','Healthy'),col=c('red','blue'),pch = c(16,16))
```


```{r bc08_cnv_ggtree, echo=FALSE}
bc02_cnv_tree = as.phylo(as.hclust(bc02_cnv$rowDendrogram))
colData = data.frame(cells=c(healthy,unhealthy),place=c(rep("Healthy",length(healthy)),rep("Cancer",length(unhealthy))))
p = ggtree(bc02_cnv_tree)
p = p %<+% colData + geom_tippoint(aes(color = place)) + geom_tiplab(size=3,hjust = -0.1) + scale_color_manual(values=c("red","blue"))
subcounts = log(t(tpms[c('ERBB2','ERBB3','MYC','PIK3CA','CCND1','BRCA1','BRCA2','ATM','TP53'),cells02])+1)
gheatmap(p,data = subcounts,offset=6, width=0.4, colnames=TRUE,font.size = 1,low='green',high='red')
```


### SCITE Output

In progress. 
